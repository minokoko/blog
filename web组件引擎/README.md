## 组件化与组件引擎  
### 背景  
一个项目越趋于开发稳定时，所考虑将会是什么？  
如何合理地开除CTO......  
&emsp;&emsp;玩笑了，往往考虑更多的是：如何提高开发效率？如何减少开发成本(开除CTO，不能降低成本？哈哈)？从制度来说，我们需要制定统一的标准，完善的开发流程；从技术来说，我们需要对资源构成，对技术进行重组。  
&emsp;&emsp;资源重组，主要是去除冗余，提取公共资源，建立公共资源库，也可以理解为建立基础服务，无论是图片、css、html片段、js工具代码；技术重组，主要淘汰不合适的技术、开发理念，采用更完善的构建流程，开发理念。  
&emsp;&emsp;无数的前端大牛已经在这条路上狂奔而去了。才有了现在前端领域各种形式的构建工具，层出不穷的解决方案，简单好用的前端框架。而组件化开发就是其中最重要的一环。像React、Vue都秉承了组件化的理念。组件化相对于后端开发，是早就存在的理念，而对于前端则不是。  
那么，前端的组件化开发是如何发展的？
### 前端组件化开发的发展
1. 静态页面时期
这是前端的开端，我们的页面多是静态页面，缺少那些令人着迷的交互。这时候的‘组件化’，或许叫做分治更为合适。即开发者将HTML、css、js创建为单独文件，减少内嵌的写法。
2. 早期的动态页面时期
有过后端开发经验的会更了解这个时期，为了满足更丰富的数据交互，出现了诸如JSP、ASP、PHP的后端渲染的技术。虽然，使页面活了起来但是页面也充满了繁杂的业务逻辑。这时的组件化是以taglib形式存在的，通过将JS、css、html独立定义为标签，通过动态引入标签来实现的。
3. Ajax时期
Ajax出现为前后端的分离带来的可行性，使前端能承担越来越多的业务逻辑。而这时的jQuery、easyUI、extjsUI等框架/工具的盛行，为了开发人员提供了越来越多的组件。开发人员可以在可选范围内，随组合使用的这些组件。
4. MV\*盛行时期
随着前端开发转向以数据模型为中心开发，DOM操作已作为附加，MV*理念开始在前端实现。Vue、Angular、React的出现使自定义组件更加灵活，伴随着Node、bower包管理工具的出现，使组件传播使用更加容易。

&emsp;&emsp;css具有全局的特性，避免样式冲突、层级繁长、难以阅读一直是要解决的痛点。最初，我们按页面结构或者业务逻辑提取出公共的样式，来管理CSS样式，但是仍然没有解决掉CSS的痛点，知道LESS/SASS出现才改变了这一现状，当然它仍然面临着样式冲突的问题。  

那么，到底什么是组件化呢？  
### 组件化  
&emsp;&emsp;组件化对于技术人员来说，是为了代码的松耦合，为了团队的相互协作，是一次技术的总结，经验的积累。总的来说，是以开发更有效率，代码更易维护扩展为目的；而对于一个项目，一个产品来说，则是利润的追逐，为了减少成本，提高开发效率。 
&emsp;&emsp;组件化的理念在后端开发已存在多年，只不过现在前端还在探索适合自身的组件化开发标准，这也正是各种组件化工具、框架大肆出现，又相继落寞的原因，即探索必有败亡。
&emsp;&emsp;组件化在前端领域并没有一个确切的定义。为了理解组件化，先理解下组件。  
&emsp;&emsp;组件，本质上是封装了所需要的业务代码，并响应了‘高内聚，低耦合’的编码原则。那么，我理解的组件是：
&emsp;&emsp;**组件是对某项功能的逻辑代码的封装。**  
组件在前端，应该是我们页面上一个个**页面的元素实现**，而组件的粒度则由我们自己去控制。例如，我们需要实现一个**个人信息提交**页面。我们既可以把这个页面当做**个人信息表单**的组件去实现，也可以具体到form表单元素为组件去实现。这就好像是乐高积木一样，我们首先实现了一个个具有独特功能的积木，然后由这些积木组合成最终所需要的玩具。  
&emsp;&emsp;那么，组件化在UI层级表现为一个个“积木”组成完成页面，而这些“积木”就是我们定义的组件标签；组件化在业务功能则表现为对一项项业务功能代码的封装，当页面需要时，我们引入该功能。
#### 组件

#### 组件实现方法
#### 组件化的开发
### 组件引擎
#### 组件引擎做什么
#### 实现引擎-组件描述
#### 实现引擎-组件加载
#### 实现引擎-组件更新
#### 实现引擎-组件销毁
#### 借鉴Vue